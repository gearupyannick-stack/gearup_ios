# Workflow for building and uploading a Flutter iOS app to TestFlight
# This job runs on a macOS runner, installs Flutter, imports your signing
# certificate and provisioning profile, builds a signed iOS archive and IPA,
# then uploads the IPA to TestFlight using the App Store Connect API key.

name: iOS Build & TestFlight Upload

# Run this workflow when you push to the main branch or trigger it manually.
on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-ios:
    # Use the latest macOS runner (macOS 14 at the time of writing)
    runs-on: macos-latest
    env:
      # Tell Flutter that this build is running on a continuous integration system.
      CI: true
    steps:
      # 1. Check out your repository
      - name: Checkout source
        uses: actions/checkout@v4

      # 2. Install Flutter SDK
      # Using subosito/flutter-action@v2 installs Flutter and adds it to PATH.
      # Pin the action version for reproducibility and use the stable channel.
      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable
          cache: true

      # 3. Install iOS and Dart/Flutter dependencies
      - name: Install dependencies
        run: flutter pub get

      # 4. Decode and install the signing assets
      #    - Decode the base64‑encoded .p12 certificate and .mobileprovision file
      #    - Create a temporary keychain and import the certificate
      #    - Copy the provisioning profile to the correct directory
      #    - Extract the UUID from the provisioning profile so xcodebuild can locate it
      - name: Install signing certificate & provisioning profile
        env:
          CERT_P12_BASE64: ${{ secrets.CERT_P12_BASE64 }}
          CERT_P12_PASSWORD: ${{ secrets.CERT_P12_PASSWORD }}
          PROV_PROFILE_BASE64: ${{ secrets.PROV_PROFILE_BASE64 }}
          KEYCHAIN_PASSWORD: ${{ secrets.RUNNER_KEYCHAIN_PASSWORD }}
        run: |
          set -e
          # Paths in the runner
          CERTIFICATE_PATH="$RUNNER_TEMP/ios_distribution.p12"
          PROV_PROFILE_PATH="$RUNNER_TEMP/profile.mobileprovision"
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"

          # Decode and write the certificate and provisioning profile to disk
          echo "$CERT_P12_BASE64" | base64 --decode > "$CERTIFICATE_PATH"
          echo "$PROV_PROFILE_BASE64" | base64 --decode > "$PROV_PROFILE_PATH"

          # Create and configure a temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import the certificate into the keychain
          security import "$CERTIFICATE_PATH" -P "$CERT_P12_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"

          # Allow Xcode tools to access the key without UI prompts
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # List keychains to include our temporary one so that Xcode finds it
          security list-keychain -d user -s "$KEYCHAIN_PATH"

          # Copy the provisioning profile into the system directory used by Xcode
          mkdir -p "${HOME}/Library/MobileDevice/Provisioning Profiles"
          cp "$PROV_PROFILE_PATH" "${HOME}/Library/MobileDevice/Provisioning Profiles/"

          # Extract the provisioning profile UUID so we can pass it to xcodebuild
          security cms -D -i "$PROV_PROFILE_PATH" > "$RUNNER_TEMP/profile.plist"
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print UUID" "$RUNNER_TEMP/profile.plist")

          echo "Provisioning profile UUID: $PROFILE_UUID"
          echo "PROFILE_UUID=$PROFILE_UUID" >> "$GITHUB_ENV"

      # 5. Build the Flutter iOS project without code signing.  This step compiles
      #    your Flutter code to an Xcode project.  Signing is deferred to the
      #    xcodebuild archive step where we can inject our manual signing settings.
      - name: Build Flutter iOS (no signing)
        run: flutter build ios --release --no-codesign

      # 6. Archive the app with Xcode and apply manual code‑signing settings.  The
      #    archive contains a signed .app bundle in a .xcarchive directory.
      - name: Create signed Xcode archive
        env:
          TEAM_ID: ${{ secrets.TEAM_ID }}
          APP_BUNDLE_ID: ${{ secrets.APP_BUNDLE_ID }}
          PROFILE_UUID: ${{ env.PROFILE_UUID }}
        run: |
          set -e
          # Ensure the build output directory exists
          mkdir -p build/ios/archive
          # Clean any previous archive to avoid stale artifacts
          rm -rf build/ios/archive/Runner.xcarchive
          # Use xcodebuild to archive the app with manual signing
          xcodebuild -workspace ios/Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -archivePath build/ios/archive/Runner.xcarchive \
            -sdk iphoneos \
            -allowProvisioningUpdates NO \
            DEVELOPMENT_TEAM="$TEAM_ID" \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            PROVISIONING_PROFILE="$PROFILE_UUID" \
            PRODUCT_BUNDLE_IDENTIFIER="$APP_BUNDLE_ID" \
            clean archive | xcpretty

      # 7. Generate an ExportOptions.plist on the fly.  This file tells Xcode
      #    how to package the archive into an IPA.  We set the method to
      #    "app-store" so that the IPA is suitable for TestFlight/App Store, and
      #    supply the team ID and provisioning profile UUID for manual signing.
      - name: Create export options
        env:
          TEAM_ID: ${{ secrets.TEAM_ID }}
          APP_BUNDLE_ID: ${{ secrets.APP_BUNDLE_ID }}
          PROFILE_UUID: ${{ env.PROFILE_UUID }}
        run: |
          cat > exportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>app-store</string>
            <key>teamID</key>
            <string>${TEAM_ID}</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${APP_BUNDLE_ID}</key>
              <string>${PROFILE_UUID}</string>
            </dict>
            <key>stripSwiftSymbols</key>
            <true/>
            <key>destination</key>
            <string>export</string>
          </dict>
          </plist>
          EOF

      # 8. Export the signed IPA from the Xcode archive
      - name: Export IPA
        run: |
          xcodebuild -exportArchive \
            -archivePath build/ios/archive/Runner.xcarchive \
            -exportPath build/ios/archive/export \
            -exportOptionsPlist exportOptions.plist | xcpretty

      # 9. Upload the resulting IPA to TestFlight.  This uses the
      #    apple-actions/upload-testflight-build action, which authenticates
      #    using your App Store Connect API key (issuer ID, key ID and private key).
      - name: Upload IPA to TestFlight
        uses: apple-actions/upload-testflight-build@v3
        with:
          app-path: build/ios/archive/export/*.ipa
          issuer-id: ${{ secrets.APP_STORE_CONNECT_API_ISSUER_ID }}
          api-key-id: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          api-private-key: ${{ secrets.APP_STORE_CONNECT_API_KEY_P8 }}

      # 10. Optionally upload the IPA as an artifact for later download or
      #     troubleshooting.  Not strictly required for TestFlight upload.
      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-build
          path: build/ios/archive/export